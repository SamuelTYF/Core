>>>
<Start>-><File>'EOF'
File.Build(new(Root));
return File;

>>>
<Space>->' '

>>>
<Space>->

>>>
<File>-><FileHeader><FileBody>

>>>
<FileHeader>->

>>>
<FileHeader>-><FileHeader><UsingNamespace><Space>

>>>
<UsingNamespace>->'using'' '<NamespaceName>';'
UsingNamespace();

>>>
<NamespaceName>->'Symbol'
NamespaceName=new();
NamespaceName.Add(Values[0].Value_String);

>>>
<NamespaceName>-><NamespaceName>'.''Symbol'
NamespaceName.Add(Values[2].Value_String);

>>>
<FileBody>->
Namespace=new();

>>>
<FileBody>-><FileBody><DefineNamespace><Space>
File.InsertNamespace(Namespace);
Namespace=new();

>>>
<DefineNamespace>->'namespace'' '<NamespaceName><Space>'{'<NamespaceItem>'}'
DefineNamespace();

>>>
<NamespaceItem>-><Space>
Type=new();

>>>
<NamespaceItem>-><NamespaceItem><DefineClass><Space>
Namespace.InsertType(Type);
Type=new();

>>>
<DefineClass>-><ClassProperty>'class'' ''Symbol'<Space>'{'<ClassItem>'}'
Type.Name=Values[3].Value_String;
Type.UpdateAttributes(Values[0] as List<string>);

>>>
<ClassProperty>->
value=new List<string>();

>>>
<ClassProperty>-><ClassProperty>'public'' '
value=Values[0];
(value as List<string>).Add(Values[1].Type);

>>>
<ClassProperty>-><ClassProperty>'static'' '
value=Values[0];
(value as List<string>).Add(Values[1].Type);

>>>
<ClassItem>-><Space>
Field=new();
Method=new();

>>>
<ClassItem>-><ClassItem><Field><Space>
Type.InsertField(Field);
Field=new();

>>>
<ClassItem>-><ClassItem><Method><Space>
Type.InsertMethod(Method);
Method=new();

>>>
<Field>-><ClassItemProperty><Type>' ''Symbol'';'
Field.Name=Values[3].Value_String;
Field.TypeFullName=Values[1] as string[];
Field.UpdateAttributes(Values[0] as List<string>);

>>>
<ClassItemProperty>->
value=new List<string>();

>>>
<ClassItemProperty>-><ClassItemProperty>'public'' '
value=Values[0];
(value as List<string>).Add(Values[1].Type);

>>>
<ClassItemProperty>-><ClassItemProperty>'static'' '
value=Values[0];
(value as List<string>).Add(Values[1].Type);

>>>
<Type>->'void'
value=new string[]{"System","Void"};

>>>
<Type>-><InternalType>
value=Values[0];

>>>
<Type>-><UserType>
value=(Values[0] as List<string>).ToArray();

>>>
<InternalType>->'int'
value=new string[]{"System","Int32"};

>>>
<UserType>->'Symbol'
value=new List<string>();
(value as List<string>).Add(Values[0].Value_String);

>>>
<UserType>-><UserType>'.''Symbol'
value=Values[0];
(value as List<string>).Add(Values[2].Value_String);

>>>
<Method>-><MethodHeader>';'
Method.IsAbstract=true;

>>>
<Method>-><MethodHeader><LambdaBody>';'
Method.Lambda=true;

>>>
<Method>-><MethodHeader><MethodBody>

>>>
<MethodHeader>-><ClassItemProperty><Type>' ''Symbol''('<Params>')'
Method.ReturnTypeFullName=Values[1] as string[];
Method.Name=Values[3].Value_String;
Method.UpdateAttributes(Values[0] as List<string>);

>>>
<Params>-><Space>

>>>
<Params>-><UserParams>

>>>
<UserParams>-><Space><Param><Space>

>>>
<UserParams>-><UserParams>','<Space><Param><Space>

>>>
<Param>-><Type>' ''Symbol'
value=new Parameter(Values[0] as string[],Values[2].Value_String);
Method.InsertParameter(value as Parameter);

>>>
<MethodBody>-><Space>'{'<MethodCommands>'}'

>>>
<MethodCommands>-><Space>

>>>
<MethodCommands>-><MethodCommands><S0>';'<Space>
Method.Commands.Add(Values[1] as ICommand);

>>>
<LambdaBody>->'=>'<S0>
Method.Commands.Add(Values[1] as ICommand);

>>>
<E0>-><S1>'='<S0>
value=new Command_Set(Values[0] as ICommand,Values[2] as ICommand);

>>>
<S0>-><E0>
value=Values[0];

>>>
<S0>-><SP>
value=Values[0];

>>>
<EP>-><SP>'?'<S1>':'<S1>
value=new Command_If(Values[0] as ICommand,Values[2] as ICommand,Values[4] as ICommand);

>>>
<SP>-><EP>
value=Values[0];

>>>
<SP>-><S1>
value=Values[0];

>>>
<E1>-><S2>'+'<S1>
value=new Command_Operator2(Values[0] as ICommand,Values[2] as ICommand,"+");

>>>
<S1>-><E1>
value=Values[0];

>>>
<S1>-><S2>
value=Values[0];

>>>
<E2>-><S3>'*'<S2>
value=new Command_Operator2(Values[0] as ICommand,Values[2] as ICommand,"*");

>>>
<E2>-><S3>'/'<S2>
value=new Command_Operator2(Values[0] as ICommand,Values[2] as ICommand,"/");

>>>
<E2>-><S3>'%'<S2>
value=new Command_Operator2(Values[0] as ICommand,Values[2] as ICommand,"%");

>>>
<S2>-><E2>
value=Values[0];

>>>
<S2>-><S3>
value=Values[0];

>>>
<E3>->'('<S0>')'
value=Values[1];

>>>
<S3>-><SR3>
value=Values[0];

>>>
<S3>-><R5>
value=Values[0];

>>>
<SR3>-><E3>
value=Values[0];

>>>
<SR3>-><E4>
value=Values[0];

>>>
<SR3>-><E5>
value=Values[0];

>>>
<E3>-><S3>'('<FunctionParams>')'
value=new Command_Call(Values[0] as ICommand,(Values[2] as List<ICommand>).ToArray());

>>>
<E4>-><SR3>'.''Symbol'
value=new Command_Get(Values[0] as ICommand,Values[2].Value_String);

>>>
<E5>->'UInt32'
value=new Command_Constant_UInt32(Values[0].Value_UInt32.Value);

>>>
<E5>->'Int32'
value=new Command_Constant<int>(Values[0].Value_Int32.Value);

>>>
<E5>->'Double'
value=new Command_Constant<double>(Values[0].Value_Double.Value);

>>>
<E5>->'Char'
value=new Command_Constant_Char(Values[0].Value_Char.Value);

>>>
<E5>->'String'
value=new Command_Constant_String(Values[0].Value_String);

>>>
<R5>-><Type>
value=new Command_Load(Values[0] as string[]);

>>>
<R5>-><Type>' ''Symbol'
Method.RegisterVariable(Values[0] as string[],Values[2].Value_String);
value=new Command_Load(Values[2].Value_String);

>>>
<FunctionParams>->
value=new List<ICommand>();

>>>
<FunctionParams>-><UserFunctionParams>
value=Values[0];

>>>
<UserFunctionParams>-><FunctionParam>
value=new List<ICommand>();
(value as List<ICommand>).Add(Values[0] as ICommand);

>>>
<UserFunctionParams>-><UserFunctionParams>','<FunctionParam>
value=Values[0];
(value as List<ICommand>).Add(Values[2] as ICommand);

>>>
<FunctionParam>-><S0>
value=Values[0];
